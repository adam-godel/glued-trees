"""
This Python script approximates a cropped Pauli list of size 200 for an arbitrary number of qubits 
by taking a smaller cropped Pauli list generated by Pauli decomposition and padding with its first
character until the desired string length is reached. This is generally reliable due to the similar 
pattern of all the Hamiltonian matrices we are using. The Pauli list generated is then added to the 
cache where it will be drawn from in the future.
"""

from functools import wraps
import json

def cache(func):
    func.cache = json.load(open('pauli_cache.json', 'r'))
    @wraps(func)
    def wrapper(dim):
        if dim in func.cache:
            return func.cache[dim]
        func.cache[dim] = func(dim)
        json.dump(func.cache, open('pauli_cache.json', 'w'))
        return func.cache[dim]
    return wrapper

@cache
def pauli_str(dim):
    cache = json.load(open('pauli_cache.json', 'r'))
    max_cache = cache[str(max([int(i) for i in cache if int(i) < dim]))]
    return [(i[0][0]*(dim-len(i[0]))+i[0], i[1]) for i in max_cache]

print('Cached values:', list(pauli_str.cache.keys()))
dim = int(input('Qubits: '))
print(pauli_str(dim))