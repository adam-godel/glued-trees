"""
This Python script approximates a cropped Pauli list of size 200 for an arbitrary number of qubits 
by taking a smaller Pauli list generated by Pauli decomposition and padding its Pauli strings
with leading identity matrices while keeping its coefficients. This is generally reliable due 
to the similar pattern of all the Hamiltonian matrices we are using. The Pauli list generated is
then added to the cache where it will be drawn from in the future.
"""

from functools import wraps
import pickle

def cache(func):
    func.cache = pickle.load(open('pauli_list.cache', 'rb'))
    @wraps(func)
    def wrapper(dim):
        if dim in func.cache:
            return func.cache[dim]
        func.cache[dim] = func(dim)
        pickle.dump(func.cache, open('pauli_list.cache', 'wb'))
        return func.cache[dim]
    return wrapper

@cache
def pauli_str(dim):
    cache = pickle.load(open('pauli_list.cache', 'rb'))
    max_cache = cache[max(cache)]
    result = []
    for i in max_cache:
        idx, length, temp = 0, 1, 1
        for j in range(1, len(i[0])):
            if j[0][i] == j[0][i-1]:
                temp += 1
            else:
                if length > temp:
                    length = temp
                    idx = j-length
                temp = 1
        result.append((max_cache[0][:idx]+max_cache[0][idx]*(dim-len(max_cache[0]))+max_cache[0][idx:], max_cache[1]))
    return result

print('Cached values:', list(pauli_str.cache.keys()))
dim = int(input('Qubits: '))
print(pauli_str(dim))